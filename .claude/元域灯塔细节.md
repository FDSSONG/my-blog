讲讲使用Redis添加逻辑过期缓存防止出现缓存穿透、缓存雪崩、缓存击穿等场景导致数据库压力过大这一条？

在系统开发中，为应对高并发场景下可能出现的缓存穿透（大量请求访问缓存和数据库中都不存在的数据 ）、缓存雪崩（大量缓存同时失效，导致大量请求涌向数据库 ）、缓存击穿（高并发下热点数据缓存失效，大量请求瞬间访问数据库 ）等问题，采用 Redis 构建缓存体系。通过设置逻辑过期时间，在数据存入 Redis 时，为其分配合理的过期时长，并配合相应的缓存更新和校验策略。当缓存数据过期时，后台异步线程或请求触发机制会对数据进行更新，从而避免因缓存问题引发的数据库压力剧增，保障系统的稳定性和高性能。

讲讲使用Redis+Lua脚本实现对用户下单资格的预检，使用RabbitMQ进行异步处理实现了解耦？

用户下单环节，利用 Redis 结合 Lua 脚本进行下单资格的预检。Lua 脚本在 Redis 环境中可原子性执行一系列指令，能够高效判断用户是否具备下单条件，如商品库存是否充足、用户是否符合购买规则等。同时，引入 RabbitMQ 消息队列，将下单成功后的后续操作（如订单处理、库存扣减通知等 ）异步化处理。将下单操作与后续复杂业务逻辑解耦，减少用户等待时间，提升系统响应速度和整体吞吐量，使系统各模块能更专注、高效地运行。

讲讲使用乐观锁实现库存精准扣减，解决秒杀产生的超卖问题？

针对秒杀等高并发场景下容易出现的超卖问题，采用乐观锁机制精准扣减库存。在数据库表设计中增加版本号或时间戳字段作为乐观锁标识。当用户下单请求到达，系统读取库存数据及对应版本号，在执行库存扣减操作时，通过比较当前版本号与数据库中记录的版本号是否一致来判断数据是否被其他线程修改。若一致，则执行扣减并更新版本号；若不一致，说明数据已被修改，当前线程重新读取库存数据重试操作，以此确保库存扣减的准确性，维护交易秩序。

高并发情况下库存判断是直接查询缓存并扣减缓存还是查mysql后扣减缓存？

高并发情况下一般优先走读写性能高的redis，降用户发起库存查询或下单请求时，会先访问 Redis 中的库存缓存。这一步的目的是快速过滤掉明显无库存的请求，比如 Redis 中显示库存为0，就直接返回库存不足，不用再请求MySQL，大幅减少数据库的访问压力，这对秒杀这类高并发场景尤其关键，能提前挡住90%以上的无效请求。

如果 Redis 显示有库存，不会直接扣减 MySQL，而是先在 Redis 中执行预扣减。这么做是为了用 Redis 的高性能承接高并发扣减请求，避免大量请求同时涌向 MySQL 导致锁等待。但 Redis 的预扣减只是临时占位，不能替代 MySQL 的持久化扣减，因为如果只扣 Redis 不扣 MySQL，一旦 Redis 宕机，预扣减的库存数据会丢失，后续重启后从 MySQL 同步数据，就会出现库存恢复但已下单用户的订单无法兑现的问题，也就是数据不一致。

所以在 Redis 预扣减后，会通过消息队列将库存扣减任务发送到后端，由消费线程异步去操作 MySQL，执行真正的库存扣减。同时会设计补偿机制，如果 MySQL 扣减失败，会反向恢复 Redis 中的库存，确保两者最终一致。如果异步任务超时，还会有定时任务校验 Redis 和 MySQL 的库存差异，兜底修正数据。

在点评平台这个项目中学到了什么，中间遇到了什么问题以及是怎么解决的？

学到了如何应对高并发场景，以及redis的挺多技术实现比如逻辑过期、redis+Lua脚本保证原子性。遇到了超卖的问题，解决方案是使用乐观锁（参考上面的问题）。

Lua脚本里大概有什么语句？  
首先会先拿外部传的参数，比如商品 ID、用户 ID、买多少件，用 ARGV 数组取，比如 local goodsId = ARGV\[1\]，再转成数字方便计算。

然后拼 Redis 里的键名，比如存库存的键是 goods:stock:商品ID，就用 local stockKey = "goods:stock:" .. goodsId 生成。

接下来是核心校验：先查库存够不够，用 redis.call("GET", stockKey) 拿当前库存，比一下是不是比要购买的数量少，少了就返回 “库存不足”；再查用户有没有超限购，比如用 user:buy:limit:用户ID:商品ID 查购买次数，超了就返回 “不能再买”。

校验过了就做预操作：用 DECRBY 减库存（比如 redis.call("DECRBY", stockKey, 买的数量)），用 INCR 加用户购买次数，最后返回 “可以下单”。

整体就是靠这些简单语句，把 “查库存、查限购、扣库存” 打包成一个不可中断的操作，避免高并发下出问题。

为什么要用lua脚本，而不是直接用redis自己的方法去实现？

一是保证多步操作的原子性。比如查库存到扣库存到记次数这几步，得连起来执行，中间不能插其他请求，否则高并发下容易超卖。直接用Redis原生命令，是分多次发请求，中间有网络间隙，可能被其他请求插队；而Lua能让这几步在 Redis 服务端一次性执行完，过程不中断，从根上避免数据乱掉。

二是减少网络折腾。不用Lua的话，几步操作要给Redis发多次请求，每次都要走客户端网络到Redis的往返。用Lua只需发一次脚本，Redis执行完直接给结果，少了很多网络来回，高并发下能明显提速、减开销。

如果有些订单超时处理失败，怎么处理的？

首先，会优先触发本地重试机制，但会控制重试的频率和次数。比如订单超时后，系统原本会执行释放库存 + 将订单标为已取消的逻辑，若执行失败，不会直接放弃，而是先尝试 1-2 次立即重试，但不会多试，因为如果是持续性故障，频繁重试反而会占用资源。同时，重试时会带上业务校验，避免因数据已被其他逻辑修改导致误操作。

如果本地重试失败，就会进入异步补偿队列重试，这是更核心的保障。把订单超时处理失败的信息封装成消息，发送到RabbitMQ这类消息队列的 “补偿队列” 中，并且给消息设置阶梯式重试间隔，比如第一次重试间隔 5 秒，第二次间隔 30 秒，第三次间隔 5 分钟，最多重试 3-5 次。这样设计的原因是，瞬时故障通常几分钟内会恢复，阶梯间隔既能避免短时间内重复冲击系统，也能提高故障恢复后的处理成功率。同时，补偿队列会开启死信队列机制。如果达到最大重试次数后仍失败，消息会被转入死信队列，避免一直占用正常队列资源。

库存扣减为什么用乐观锁不用redis+lua脚本？

秒杀场景的库存扣减最终要落地到 MySQL 数据库。如果用 Redis+Lua 做前置扣减，需要额外处理Redis 库存与 MySQL 库存同步的问题，比如 Redis 扣减后，MySQL 扣减失败怎么办，是否要做补偿机制，这会增加业务逻辑的复杂度。而乐观锁直接基于 MySQL 操作，库存扣减和版本号校验在同一个数据库事务中完成，天然能保证扣减成功则数据落地，失败则回滚。