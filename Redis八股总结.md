# Redis 八股文知识脉络

## 📚 整体知识框架

```
Redis八股
├── 1. 基础架构篇
├── 2. 持久化篇
├── 3. 高可用与集群篇
├── 4. 缓存异常篇
├── 5. 缓存策略篇
├── 6. 分布式锁篇
└── 7. 高级特性篇
```

---

## 1. 🏗️ 基础架构篇

### 核心问题
- [ ] Redis为什么这么快？（高性能的三大基石）
- [ ] Redis常用数据结构底层实现是怎样的？（SDS、Ziplist等）
- [ ] Redis 6.0 为什么要引入多线程？
- [ ] Redis的IO模型是怎样的？

### 关键知识点细化
#### 1. 高性能基石
- **纯内存操作**：数据存在内存中，读写速度接近 CPU 内存访问速度。
- **单线程模型**：
  - 避免了多线程频繁的上下文切换（Context Switch）。
  - 无需加锁，没有竞争开销，不存在死锁问题。
- **IO多路复用 (Epoll)**：
  - 使用 Reactor 模式，单线程同时监控多个 FD（File Descriptor）。
  - 实现了非阻塞 IO，吞吐量极高。

#### 2. 底层数据结构
- **SDS (Simple Dynamic String)**：
  - **结构**：`len` (长度), `alloc` (分配空间), `buf` (字节数组)。
  - **优势**：O(1)获取长度；二进制安全（存图片/视频）；杜绝缓冲区溢出；减少内存重分配。
- **Hash**：
  - **Ziplist (压缩列表)**：连续内存块，省内存，适合小数据。
  - **Hashtable**：Dict 结构，渐进式 Rehash。
- **ZSet**：
  - **Ziplist**：元素少时。
  - **Skiplist (跳表)**：O(logN) 查询，层级结构，空间换时间，替代平衡树。

#### 3. 线程模型演进
- **4.0 之前**：完全单线程。
- **4.0**：引入后台线程处理耗时任务（如 `UNLINK` 删除大 Key）。
- **6.0**：引入 **多线程 IO**。
  - **原因**：Redis 瓶颈在于网络 IO 和内存，而非 CPU。
  - **实现**：主线程负责命令执行（保证逻辑原子性），IO 线程负责网络数据的读写解析。

---

## 2. 💾 持久化篇

### 核心问题
- [ ] RDB 和 AOF 的执行流程和区别？
- [ ] 为什么 `bgsave` 不会阻塞主线程？（Copy-on-Write）
- [ ] AOF 重写是如何实现的？
- [ ] 混合持久化是什么？

### 关键知识点细化
#### 1. RDB (Redis Database)
- **机制**：内存快照（Snapshot）。
- **触发**：`save` (阻塞), `bgsave` (fork 子进程，不阻塞)。
- **Copy-on-Write (COW)**：
  - Linux `fork()` 产生子进程，父子进程共享物理内存。
  - 只有当父进程**写数据**时，操作系统才会复制被修改的内存页（Page），保证子进程读取的是 fork 时刻的数据副本。

#### 2. AOF (Append Only File)
- **机制**：记录所有写命令日志。
- **刷盘策略 (`appendfsync`)**：
  - `Always`：每条命令都刷盘（慢，安全）。
  - `Everysec`：每秒刷盘一次（默认，折中）。
  - `No`：由操作系统决定（快，不安全）。
- **AOF 重写 (Rewrite)**：
  - **目的**：压缩 AOF 文件体积（例如 `INCR` 100 次 -> `SET` 100）。
  - **流程**：`bgrewriteaof` -> fork 子进程 -> 遍历内存生成新 AOF -> 主线程缓冲期间的新写操作 -> 原子替换旧文件。

#### 3. 混合持久化 (4.0+)
- **原理**：RDB 镜像 + AOF 增量日志。
- **优势**：重启加载快（利用 RDB），数据丢失少（利用 AOF）。

---

## 3. 🌐 高可用与集群篇

### 核心问题
- [ ] 哨兵 (Sentinel) 如何判断主节点下线？(主观下线 vs 客观下线)
- [ ] 哨兵的 Leader 选举过程？(Raft 协议)
- [ ] Redis Cluster 的数据分片原理？(Hash Slot)
- [ ] 什么是 Gossip 协议？

### 关键知识点细化
#### 1. 主从复制
- **全量复制**：第一次同步，发送 RDB 文件。
- **增量复制**：网络抖动断连后，通过 `repl_backlog_buffer` (环形缓冲区) 补发差异数据 (Offset)。

#### 2. 哨兵机制 (Sentinel)
- **监控**：每秒 Ping，判断存活。
  - **主观下线 (SDOWN)**：单个哨兵认为 Master 挂了。
  - **客观下线 (ODOWN)**：超过 Quorum 数量的哨兵认为 Master 挂了。
- **故障转移**：选举一个哨兵 Leader 执行 `slaveof no one`，通知客户端。

#### 3. Cluster 集群
- **Hash Slot (即哈希槽)**：共 16384 个槽。
  - 算法：`CRC16(key) % 16384`。
  - 节点维护槽映射关系。
- **MOVED vs ASK 错误**：
  - `MOVED`：槽位已永久迁移，客户端更新路由缓存。
  - `ASK`：槽位迁移中，临时访问目标节点。
- **Gossip 协议**：节点间通信（Ping, Pong, Meet, Fail），去中心化，最终一致性。

---

## 4. ⚠️ 缓存异常篇

### 核心问题
- [ ] 缓存穿透、击穿、雪崩的区别和解决方案？
- [ ] 布隆过滤器 (Bloom Filter) 的原理和误判问题？
- [ ] 缓存与数据库一致性问题（先删还是后删？）

### 关键知识点细化
#### 1. 三大异常
| 异常 | 现象 | 原因 | 解决方案 |
|---|---|---|---|
| **穿透** | 查不存在的数据 | 恶意攻击/代码Bug | 1. 缓存空值 (Key-Null)<br>2. **布隆过滤器 (Bloom Filter)** |
| **击穿** | 热点Key失效 | 单个热点Key过期 | 1. **互斥锁 (Mutex Lock)**<br>2. 逻辑过期 (不设TTL，异步更新) |
| **雪崩** | 大量Key失效 | 集中过期/Redis宕机 | 1. **随机TTL** (过期时间加随机值)<br>2. 熔断降级<br>3. Redis 高可用 |

#### 2. 双写一致性 (Consistency)
- **Cache Aside Pattern (旁路缓存)**：
  - **读**：先读缓存 -> 没命中读 DB -> 写入缓存。
  - **写**：先更新 DB -> **再删除缓存**。
- **为什么删缓存而不是更新？**：防止并发写导致脏数据；节省内存（Lazy Loading）。
- **延时双删**：`del -> update -> sleep -> del`，解决主从延迟导致的脏数据。

---

## 5. 🧹 缓存策略篇

### 核心问题
- [ ] Redis 过期键的删除策略是什么？
- [ ] 内存满了怎么办？(驱逐策略)
- [ ] LRU 和 LFU 算法在 Redis 中是如何实现的？

### 关键知识点细化
#### 1. 过期策略
- **惰性删除 (Lazy)**：访问 Key 时检查，过期则删。
- **定期删除 (Periodic)**：每隔 100ms 随机抽取 Key 检查，过期则删。
- **Redis 策略**：同时开启配合使用。

#### 2. 内存淘汰机制 (Eviction)
- `noeviction`：报错（默认）。
- `allkeys-lru`：所有 Key 中最少使用的。
- `volatile-lru`：设了过期时间的 Key 中最少使用的。
- `allkeys-random` / `volatile-random`：随机。
- `volatile-ttl`：即将过期的。

#### 3. 算法实现
- **近似 LRU**：随机采样 5 个 Key，淘汰最旧的（节省内存链表开销）。
- **LFU (Least Frequently Used)**：记录访问频率（Counter），解决 "虽久未用但刚被访问一次" 导致没被 LRU 淘汰的问题。

---

## 6. 🔒 分布式锁篇

### 核心问题
- [ ] SETNX 实现分布式锁的缺陷？
- [ ] 如何保证锁的原子性？(Lua 脚本)
- [ ] 锁超时了业务没跑完怎么办？(Watchdog)
- [ ] Redlock 算法流程？

### 关键知识点细化
#### 1. 基础实现
- **命令**：`SET key unique_id NX PX 10000` (原子性：存在判断 + 设置过期)。
- **解锁**：必须校验 `unique_id`，防止删别人的锁。
  - **Lua 脚本**：确保 `GET` 和 `DEL` 原子执行。
  ```lua
  if redis.call("get",KEYS[1]) == ARGV[1] then
      return redis.call("del",KEYS[1])
  else
      return 0
  end
  ```

#### 2. Redisson 框架
- **Watchdog (看门狗)**：
  - 守护线程，每隔 10s (默认锁时长的 1/3) 检查，如果从线程还持有锁，自动续期。
- **可重入锁**：Hash 结构记录线程 ID 和计数器。

#### 3. Redlock (红锁)
- **场景**：解决 Redis 主从异步复制可能导致的锁丢失问题。
- **原理**：向 N 个独立节点依次申请锁，只要过半节点 (N/2 + 1) 成功且总耗时 < 锁有效期，则加锁成功。

---

## 7. 🚀 高级特性篇

### 核心问题
- [ ] Pipeline 和 Transaction 的区别？
- [ ] SCAN 命令怎么用？为什么不建议用 KEYS *？
- [ ] BigKey 的危害及处理？

### 关键知识点细化
#### 1. 性能优化
- **Pipeline (管道)**：
  - 客户端缓冲多条命令，一次性发送。
  - 减少 RTT (Round Trip Time)，极大提升吞吐。
- **Lua 脚本**：
  - 服务端原子执行多条命令。
  - 减少网络传输。

#### 2. 运维指令
- **SCAN**：
  - 基于游标 (Cursor) 的迭代器。
  - O(1) 复杂度，不会阻塞主线程（`KEYS *` 是 O(N) 全量扫描，会阻塞）。
- **BigKey**：
  - **危害**：操作耗时阻塞主线程；网络带宽打满。
  - **发现**：`redis-cli --bigkeys`。
  - **删除**：使用 `UNLINK` (异步删除)。

---

## ✅ 学习进度追踪

| 模块 | 状态 | 掌握程度 |
|------|------|----------|
| 1. 基础架构篇 | ⬜ 未开始 | ☆☆☆☆☆ |
| 2. 持久化篇 | ⬜ 未开始 | ☆☆☆☆☆ |
| 3. 高可用与集群篇 | ⬜ 未开始 | ☆☆☆☆☆ |
| 4. 缓存异常篇 | ⬜ 未开始 | ☆☆☆☆☆ |
| 5. 缓存策略篇 | ⬜ 未开始 | ☆☆☆☆☆ |
| 6. 分布式锁篇 | ⬜ 未开始 | ☆☆☆☆☆ |
| 7. 高级特性篇 | ⬜ 未开始 | ☆☆☆☆☆ |

---

> 💡 **专家建议**：Redis 知识点非常细碎，建议围绕 **"高可用 (HA)"** 和 **"高并发 (High Concurrency)"** 两条主线串联所有知识点。例如，持久化是为了 HA，IO 多路复用是为了 High Concurrency。
