# 消息队列 (MQ) 八股文知识脉络

## 📚 整体知识框架

```
MQ八股
├── 1. 基础概念篇
├── 2. 可靠性篇 (如何不丢消息)
├── 3. 消费机制篇 (顺序与幂等)
├── 4. 高可用架构篇
├── 5. 运维与异常篇 (积压与事务)
└── 6. 技术选型对比篇
```

---

## 1. 🏗️ 基础概念篇

### 核心问题
- [ ] 为什么要使用消息队列？(核心应用场景)
- [ ] 使用消息队列有什么缺点？
- [ ] 消息队列有哪些通信模型？(Push vs Pull)

### 关键知识点细化
#### 1. 核心场景 (解耦、异步、削峰)
- **解耦 (Decoupling)**：A系统调用B系统，A无需等待B挂掉或修改接口。
  - *例*：订单系统 -> 库存系统/积分系统/短信系统。
- **异步 (Asynchronous)**：提升响应速度，耗时操作放入后台处理。
  - *例*：用户注册后，异步发送欢迎邮件。
- **削峰填谷 (Peak Shaving)**：应对突发流量，保护后端数据库。
  - *例*：秒杀活动，请求先入 MQ，服务端按能力拉取处理。

#### 2. 引入的缺点
- **系统可用性降低**：MQ 挂了，整个链路受影响。
- **系统复杂度提高**：需要考虑一致性、重复消费、顺序消费等问题。
- **一致性问题**：A 系统成功，B 系统失败，导致数据不一致。

#### 3. 通信模型
- **点对点 (P2P)**：每个消息只有一个消费者 (Queue)。
- **发布/订阅 (Pub/Sub)**：消息广播给所有订阅者 (Topic)。
- **Push (推)**：实时性高，但可能压垮消费者。
- **Pull (拉)**：消费者按需控制速率，但会有轮询延迟。

---

## 2. 🛡️ 可靠性篇 (如何保证消息不丢失)

### 核心问题
- [ ] 消息丢失可能发生在哪些环节？
- [ ] 生产者如何保证消息发送成功？
- [ ] MQ 服务端 (Broker) 如何保证不丢数据？
- [ ] 消费者如何保证消息被成功处理？

### 关键知识点细化
#### 1. 生产端可靠性
- **ACK 机制**：发送后等待 Broker 确认。
- **重试机制 (Retry)**：失败后自动重试发送。
- **事务消息**：(RocketMQ 特有) 确保本地事务执行与消息发送的原子性。

#### 2. 服务端 (Broker) 可靠性
- **持久化 (Persistence)**：写入磁盘 (WAL - Write Ahead Log)。
  - *同步刷盘*：写磁盘成功才返回 ACK (安全但慢)。
  - *异步刷盘*：写内存即返回 ACK (快但有丢失风险)。
- **多副本 (Replication)**：
  - Leader/Master 收到数据后，同步给 Follower/Slave。
  - `min.insync.replicas` (Kafka)：至少写入 N 个副本才算成功。

#### 3. 消费端可靠性
- **手动 ACK (Manual ACK)**：业务逻辑执行成功后，再向 MQ 发送确认。
  - *自动 ACK* 的风险：拿到消息还没处理，程序挂了，消息丢失。

---

## 3. 🔄 消费机制篇 (顺序与幂等)

### 核心问题
- [ ] 如何保证消息消费的幂等性？(重复消费怎么办)
- [ ] 如何保证消息的顺序性？
- [ ] 消息积压了怎么处理？

### 关键知识点细化
#### 1. 幂等性 (Idempotency)
- **原因**：网络抖动导致 ACK 丢失，Producer/Broker 重发消息。
- **解决方案**：
  - **数据库唯一约束 (Unique Key)**：最简单可靠。
  - **Redis 防重**：`SET key_id value NX`，处理前先查是否存在。
  - **业务状态机**：`Update order set status = done where id = 1 and status = init` (CAS 思想)。

#### 2. 顺序消费 (Ordering)
- **全局顺序**：单一 Partition/Queue，单一 Consumer (吞吐量低)。
- **分区顺序**：
  - 发送端：将同一个 ID (如 OrderId) 的消息发送到同一个 Partition。
  - 消费端：保证一个 Partition 只由一个线程处理（或内存队列排队）。

---

## 4. 🌐 高可用架构篇

### 核心问题
- [ ] Kafka 的高可用架构是怎样的？
- [ ] RocketMQ 的 Master-Slave 架构？
- [ ] RabbitMQ 的镜像队列模式？

### 关键知识点细化
#### 1. Kafka
- **Partition 副本机制**：Leader 负责读写，Follower 被动同步。
- **ISR (In-Sync Replicas)**：动态维护的同步列表，Leader 挂了从 ISR 中选新 Leader。
- **Controller**：协调者，负责选举。

#### 2. RocketMQ
- **Dledger (Raft)**：4.5+ 版本引入，支持自动选主 Failover。
- **NameServer**：无状态注册中心，Broker 上报信息。

---

## 5. 🛠️ 运维与异常篇

### 核心问题
- [ ] 线上大量消息积压怎么处理？
- [ ] 如何实现分布式事务 (最终一致性)？
- [ ] 延时队列如何实现？

### 关键知识点细化
#### 1. 消息积压 (Lag) 紧急处理
- **方案**：
  1. 修复 Consumer Bug (如果是 Bug 导致)。
  2. **临时扩容**：将 Consumer 逻辑改为 "只取不处理，转发到新的 Topic (Partition*10)"。
  3. 启动 10 倍数量的 Worker 消费新的 Topic。

#### 2. 分布式事务
- **RocketMQ 事务消息**：
  - Half Message -> 执行本地事务 -> Commit/Rollback -> (如果超时) Broker 回查事务状态。
- **本地消息表**：业务 DB 中存消息表 -> 定时任务轮询发送 -> 成功删表记录。

---

## 6. ⚖️ 技术选型对比篇

### 核心问题
- [ ] Kafka, RocketMQ, RabbitMQ 怎么选？
- [ ] 各自的优缺点是什么？

### 关键知识点细化
| 特性 | RabbitMQ | RocketMQ | Kafka |
|---|---|---|---|
| **语言** | Erlang | Java | Scala/Java |
| **单机吞吐** | 万级 | 十万级 | **百万级** |
| **时效性** | **微秒级** | 毫秒级 | 毫秒级 |
| **可用性** | 高 (镜像队列) | 非常高 (Dledger) | 非常高 |
| **功能特性** | 并发能力强，路由灵活 | **事务消息**，延时消息，Tag过滤 | 仅核心MQ功能，流处理 |
| **适用场景** | 中小型公司，复杂路由 | 互联网金融，核心业务链路 | **大数据日志采集**，实时计算 |

---

## ✅ 学习进度追踪

| 模块 | 状态 | 掌握程度 |
|------|------|----------|
| 1. 基础概念 | ⬜ 未开始 | ☆☆☆☆☆ |
| 2. 可靠性机制 | ⬜ 未开始 | ☆☆☆☆☆ |
| 3. 消费机制 (幂等/顺序) | ⬜ 未开始 | ☆☆☆☆☆ |
| 4. 高可用架构 | ⬜ 未开始 | ☆☆☆☆☆ |
| 5. 运维与异常 | ⬜ 未开始 | ☆☆☆☆☆ |
| 6. 技术选型 | ⬜ 未开始 | ☆☆☆☆☆ |

---

> 💡 **专家建议**：面试中这三点是必问的：**"丢了怎么办(可靠性)"**、**"重复了怎么办(幂等性)"**、**"积压了怎么办"**。
